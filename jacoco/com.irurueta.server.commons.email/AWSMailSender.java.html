<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>AWSMailSender.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">com.irurueta:irurueta-server-commons-email</a> &gt; <a href="index.source.html" class="el_package">com.irurueta.server.commons.email</a> &gt; <span class="el_source">AWSMailSender.java</span></div><h1>AWSMailSender.java</h1><pre class="source lang-java linenums">/*
 * Copyright (C) 2016 Alberto Irurueta Carro (alberto@irurueta.com)
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.irurueta.server.commons.email;

import com.amazonaws.auth.BasicAWSCredentials;
import com.amazonaws.services.simpleemail.AmazonSimpleEmailServiceClient;
import com.amazonaws.services.simpleemail.model.Destination;
import com.amazonaws.services.simpleemail.model.GetSendQuotaResult;
import com.amazonaws.services.simpleemail.model.Message;
import com.amazonaws.services.simpleemail.model.RawMessage;
import com.amazonaws.services.simpleemail.model.SendEmailRequest;
import com.amazonaws.services.simpleemail.model.SendEmailResult;
import com.amazonaws.services.simpleemail.model.SendRawEmailRequest;
import com.amazonaws.services.simpleemail.model.SendRawEmailResult;
import com.irurueta.server.commons.configuration.ConfigurationException;

import java.io.ByteArrayOutputStream;
import java.lang.ref.SoftReference;
import java.nio.ByteBuffer;
import java.util.Properties;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.mail.Session;
import javax.mail.internet.MimeMessage;

/**
 * Class to send emails using Amazon Web Services (AWS) SES.
 */
public class AWSMailSender extends
        EmailSender&lt;Message&gt; {

    /**
     * Logger for this class.
     */
<span class="fc" id="L48">    public static final Logger LOGGER = Logger.getLogger(</span>
<span class="fc" id="L49">            AWSMailSender.class.getName());</span>

    /**
     * Milliseconds to wait to check quota.
     */
    public static final long DEFAULT_CHECK_QUOTA_AFTER_MILLIS = 3600000;

    /**
     * Number of sent mails to take into account before checking quota.
     */
    public static final long MIN_CHECK_QUOTA_AFTER_MILLIS = 0;

    /**
     * Number of milliseconds in a second.
     */
    private static final double MILLISECONDS_PER_SECOND = 1000.0;

    /**
     * Reference to singleton instance of this class.
     */
    private static SoftReference&lt;AWSMailSender&gt; mReference;

    /**
     * AWS SES credentials.
     */
    private AWSEmailSenderCredentials mCredentials;

    /**
     * Email address to be used as sender.
     */
    private String mMailFromAddress;

    /**
     * Indicates whether email sender is enabled or not.
     */
    private boolean mEnabled;

    /**
     * Internal client to be used for mail sending.
     */
    private AmazonSimpleEmailServiceClient mClient;

    /**
     * Indicates amount of milliseconds to check quota of mail sending returned
     * by Amazon. This is used to prevent Amazon SES throttling.
     */
    private volatile long mCheckQuotaAfterMillis;

    /**
     * Timestamps of last sent email.
     */
    private volatile long mLastSentMailTimestamp;

    /**
     * Amount of milliseconds to wait when next email must be sent if quota is
     * exceeded.
     */
    private volatile long mWaitIntervalMillis;

    /**
     * Constructor.
     * Loads mail configuration, and if it fails for some reason, mail sending
     * becomes disabled.
     */
<span class="fc" id="L113">    private AWSMailSender() {</span>

        try {
<span class="fc" id="L116">            final MailConfiguration cfg = MailConfigurationFactory.getInstance().</span>
<span class="fc" id="L117">                    configure();</span>
<span class="fc" id="L118">            mCredentials = cfg.getAWSMailCredentials();</span>
<span class="fc" id="L119">            mMailFromAddress = cfg.getMailFromAddress();</span>

<span class="fc bfc" id="L121" title="All 2 branches covered.">            mEnabled = mMailFromAddress != null &amp;&amp;</span>
<span class="pc bpc" id="L122" title="1 of 2 branches missed.">                    isValidEmailAddress(mMailFromAddress) &amp;&amp;</span>
<span class="pc bpc" id="L123" title="1 of 2 branches missed.">                    cfg.isMailSendingEnabled();</span>
<span class="fc" id="L124">            mCheckQuotaAfterMillis = cfg.getAWSMailCheckQuotaAfterMillis();</span>
<span class="fc" id="L125">            mLastSentMailTimestamp = 0;</span>
<span class="fc" id="L126">            mWaitIntervalMillis = 0;</span>
<span class="nc" id="L127">        } catch (final ConfigurationException e) {</span>
<span class="nc" id="L128">            mEnabled = false;</span>
<span class="fc" id="L129">        }</span>

<span class="fc bfc" id="L131" title="All 2 branches covered.">        if (mEnabled) {</span>
<span class="fc" id="L132">            LOGGER.log(Level.INFO, &quot;AWS Email Sender enabled.&quot;);</span>
        } else {
<span class="fc" id="L134">            LOGGER.log(Level.INFO, &quot;AWS Email Sender disabled. Any &quot; +</span>
                    &quot;attempt to send emails using AWS SES will be &quot; +
                    &quot;silently ignored&quot;);
        }
<span class="fc" id="L138">    }</span>

    /**
     * Returns or creates singleton instance of this class.
     *
     * @return singleton of this class.
     */
    public static synchronized AWSMailSender getInstance() {
        AWSMailSender sender;
<span class="pc bpc" id="L147" title="1 of 4 branches missed.">        if (mReference == null || (sender = mReference.get()) == null) {</span>
<span class="fc" id="L148">            sender = new AWSMailSender();</span>
<span class="fc" id="L149">            mReference = new SoftReference&lt;&gt;(sender);</span>
        }
<span class="fc" id="L151">        return sender;</span>
    }

    /**
     * Resets AWSMailSender singleton.
     */
    public static synchronized void reset() {
<span class="fc" id="L158">        mReference = null;</span>
<span class="fc" id="L159">    }</span>

    /**
     * Returns AWS SES credentials.
     *
     * @return Amazon Web Services Simple Email Service credentials.
     */
    public AWSEmailSenderCredentials getCredentials() {
<span class="fc" id="L167">        return mCredentials;</span>
    }

    /**
     * Email address to send emails from.
     *
     * @return email address to send emails from.
     */
    public String getMailFromAddress() {
<span class="fc" id="L176">        return mMailFromAddress;</span>
    }

    /**
     * Indicates if this mail sender controller is enabled.
     *
     * @return true if enabled, false otherwise
     */
    public boolean isEnabled() {
<span class="fc" id="L185">        return mEnabled;</span>
    }

    /**
     * Amount of milliseconds to wait before checking sending quota.
     *
     * @return amount of milliseconds to wait before checking sending quota.
     */
    public long getCheckQuotaAfterMillis() {
<span class="fc" id="L194">        return mCheckQuotaAfterMillis;</span>
    }

    /**
     * Method to send an email.
     *
     * @param m email message to be sent.
     * @return id of message that has been sent.
     * @throws MailNotSentException if mail couldn't be sent.
     */
    @Override
    public String send(final EmailMessage&lt;Message&gt; m) throws MailNotSentException {
        // to avoid compilation errors because of casting
<span class="fc bfc" id="L207" title="All 2 branches covered.">        if (m instanceof AWSTextEmailMessage) {</span>
<span class="fc" id="L208">            return sendTextEmail((AWSTextEmailMessage) m);</span>
<span class="fc bfc" id="L209" title="All 2 branches covered.">        } else if ((EmailMessage&lt;?&gt;) m instanceof AWSTextEmailMessageWithAttachments) {</span>
<span class="fc" id="L210">            return sendRawEmail((AWSTextEmailMessageWithAttachments) (EmailMessage&lt;?&gt;) m);</span>
<span class="pc bpc" id="L211" title="1 of 2 branches missed.">        } else if ((EmailMessage&lt;?&gt;) m instanceof AWSHtmlEmailMessage) {</span>
<span class="fc" id="L212">            return sendRawEmail((AWSHtmlEmailMessage) (EmailMessage&lt;?&gt;) m);</span>
        } else {
<span class="nc" id="L214">            throw new MailNotSentException(&quot;Unsupported email type&quot;);</span>
        }
    }

    /**
     * Returns provider used by this email sender.
     *
     * @return email provider.
     */
    @Override
    public EmailProvider getProvider() {
<span class="fc" id="L225">        return EmailProvider.AWS_MAIL;</span>
    }

    /**
     * Method to send a text email.
     *
     * @param m email message to be sent.
     * @return id of message that has been sent.
     * @throws MailNotSentException if mail couldn't be sent.
     */
    private String sendTextEmail(final AWSTextEmailMessage m)
            throws MailNotSentException {
        final String messageId;
<span class="fc" id="L238">        final long currentTimestamp = System.currentTimeMillis();</span>
<span class="fc" id="L239">        prepareClient();</span>
<span class="fc bfc" id="L240" title="All 2 branches covered.">        if (!mEnabled) {</span>
            // don't send message if not enabled
<span class="fc" id="L242">            return null;</span>
        }

        try {
<span class="fc" id="L246">            synchronized (this) {</span>
                // prevents throttling
<span class="fc" id="L248">                checkQuota(currentTimestamp);</span>

<span class="fc" id="L250">                final Destination destination = new Destination(m.getTo());</span>
<span class="pc bpc" id="L251" title="2 of 4 branches missed.">                if (m.getBCC() != null &amp;&amp; !m.getBCC().isEmpty()) {</span>
<span class="nc" id="L252">                    destination.setBccAddresses(m.getBCC());</span>
                }
<span class="pc bpc" id="L254" title="2 of 4 branches missed.">                if (m.getCC() != null &amp;&amp; !m.getCC().isEmpty()) {</span>
<span class="nc" id="L255">                    destination.setCcAddresses(m.getCC());</span>
                }

                // if no subject, set to empty string to avoid errors
<span class="pc bpc" id="L259" title="1 of 2 branches missed.">                if (m.getSubject() == null) {</span>
<span class="nc" id="L260">                    m.setSubject(&quot;&quot;);</span>
                }

<span class="fc" id="L263">                final Message message = new Message();</span>
<span class="fc" id="L264">                m.buildContent(message);</span>

<span class="fc" id="L266">                final SendEmailResult result = mClient.sendEmail(new SendEmailRequest(mMailFromAddress, destination,</span>
                        message));
<span class="fc" id="L268">                messageId = result.getMessageId();</span>
                // update timestamp of last sent email
<span class="fc" id="L270">                mLastSentMailTimestamp = System.currentTimeMillis();</span>

                // wait to avoid throttling exceptions to avoid making any
                // further requests
<span class="fc" id="L274">                final long endTimestamp = currentTimestamp + mWaitIntervalMillis;</span>
<span class="pc bpc" id="L275" title="1 of 2 branches missed.">                while (System.currentTimeMillis() &lt; endTimestamp) {</span>
<span class="nc" id="L276">                    wait(mWaitIntervalMillis);</span>
                }
<span class="fc" id="L278">            }</span>
<span class="nc" id="L279">        } catch (final Exception e) {</span>
<span class="nc" id="L280">            throw new MailNotSentException(e);</span>
<span class="fc" id="L281">        }</span>
<span class="fc" id="L282">        return messageId;</span>
    }

    /**
     * Method to send a text email with attachments or HTML emails with
     * attachments (inline or not).
     *
     * @param m email message to be sent.
     * @return id of message that has been sent.
     * @throws MailNotSentException if mail couldn't be sent.
     */
    private String sendRawEmail(final EmailMessage&lt;MimeMessage&gt; m)
            throws MailNotSentException {

        final String messageId;
<span class="fc" id="L297">        final long currentTimestamp = System.currentTimeMillis();</span>
<span class="fc" id="L298">        prepareClient();</span>
<span class="pc bpc" id="L299" title="1 of 2 branches missed.">        if (!mEnabled) {</span>
            // don't send message if not enabled
<span class="nc" id="L301">            return null;</span>
        }

        try {
<span class="fc" id="L305">            synchronized (this) {</span>
                // prevents throttling and excessive memory usage
<span class="fc" id="L307">                checkQuota(currentTimestamp);</span>

                // if no subject, set to empty string to avoid errors
<span class="pc bpc" id="L310" title="1 of 2 branches missed.">                if (m.getSubject() == null) {</span>
<span class="nc" id="L311">                    m.setSubject(&quot;&quot;);</span>
                }

<span class="fc" id="L314">                final ByteArrayOutputStream outputStream =</span>
                        new ByteArrayOutputStream();

                // convert message into mime multi part and write it to output
                // stream into memory
<span class="fc" id="L319">                final Session session = Session.getInstance(new Properties());</span>
<span class="fc" id="L320">                final MimeMessage mimeMessage = new MimeMessage(session);</span>
<span class="pc bpc" id="L321" title="1 of 2 branches missed.">                if (m.getSubject() != null) {</span>
<span class="fc" id="L322">                    mimeMessage.setSubject(m.getSubject(), &quot;utf-8&quot;);</span>
                }
<span class="fc" id="L324">                m.buildContent(mimeMessage);</span>
<span class="fc" id="L325">                mimeMessage.writeTo(outputStream);</span>

<span class="fc" id="L327">                final RawMessage rawMessage = new RawMessage(ByteBuffer.wrap(</span>
<span class="fc" id="L328">                        outputStream.toByteArray()));</span>

<span class="fc" id="L330">                final SendRawEmailRequest rawRequest = new SendRawEmailRequest(</span>
                        rawMessage);
<span class="fc" id="L332">                rawRequest.setDestinations(m.getTo());</span>
<span class="fc" id="L333">                rawRequest.setSource(mMailFromAddress);</span>
<span class="fc" id="L334">                SendRawEmailResult result = mClient.sendRawEmail(rawRequest);</span>
<span class="fc" id="L335">                messageId = result.getMessageId();</span>

                // update timestamp of last sent email
<span class="fc" id="L338">                mLastSentMailTimestamp = System.currentTimeMillis();</span>

                // wait to avoid throttling exceptions to avoid making any
                // further requests
<span class="fc" id="L342">                final long endTimestamp = currentTimestamp + mWaitIntervalMillis;</span>
<span class="pc bpc" id="L343" title="1 of 2 branches missed.">                while (System.currentTimeMillis() &lt; endTimestamp) {</span>
<span class="nc" id="L344">                    wait(mWaitIntervalMillis);</span>
                }
<span class="fc" id="L346">            }</span>
<span class="nc" id="L347">        } catch (final Exception e) {</span>
<span class="nc" id="L348">            throw new MailNotSentException(e);</span>
<span class="fc" id="L349">        }</span>

<span class="fc" id="L351">        return messageId;</span>
    }

    /**
     * Checks quota of sent emails to prevent AWS SES throttling.
     *
     * @param currentTimestamp current timestamp.
     */
    private synchronized void checkQuota(final long currentTimestamp) {
<span class="fc bfc" id="L360" title="All 2 branches covered.">        if ((currentTimestamp - mLastSentMailTimestamp) &gt;</span>
                mCheckQuotaAfterMillis) {
            // check quota to determine the number of messages per second to
            // avoid throttling exceptions
<span class="fc" id="L364">            final GetSendQuotaResult quota = mClient.getSendQuota();</span>
            // update interval that we must wait between send requests
<span class="fc" id="L366">            mWaitIntervalMillis = (long) Math.ceil(</span>
<span class="fc" id="L367">                    MILLISECONDS_PER_SECOND / quota.getMaxSendRate());</span>
        }
<span class="fc" id="L369">    }</span>

    /**
     * Prepares client by setting proper credentials.
     */
    private synchronized void prepareClient() {
<span class="fc bfc" id="L375" title="All 2 branches covered.">        if (mClient == null) {</span>
            // instantiate new client if needed
<span class="fc bfc" id="L377" title="All 2 branches covered.">            if (areValidCredentials()) {</span>
<span class="fc" id="L378">                mClient = new AmazonSimpleEmailServiceClient(</span>
<span class="fc" id="L379">                        new BasicAWSCredentials(mCredentials.getAccessKey(),</span>
<span class="fc" id="L380">                                mCredentials.getSecretKey()));</span>
            } else {
                // disabling mail sending
<span class="fc" id="L383">                mEnabled = false;</span>
<span class="fc" id="L384">                Logger.getLogger(AWSMailSender.class.getName()).log(</span>
                        Level.INFO, &quot;AWS Email Sender disabled. &quot; +
                                &quot;Invalid credentials&quot;);
            }
        }
<span class="fc" id="L389">    }</span>

    /**
     * Indicates whether provided credentials are valid.
     *
     * @return true if credentials are valid, false otherwise.
     */
    private boolean areValidCredentials() {
<span class="pc bpc" id="L397" title="1 of 2 branches missed.">        if (mCredentials != null) {</span>
<span class="fc" id="L398">            return mCredentials.isReady();</span>
        } else {
<span class="nc" id="L400">            return false;</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>